
# Project: LangChain Output Parsers with GPT-3.5

This project demonstrates the use of LangChain's output parsers in combination with OpenAI's GPT-3.5 model to handle and structure outputs for various types of queries. The project covers three types of parsers: List Parser, Structured Parser, and Class-based (Pydantic) Parser.

## Setup Instructions

### Prerequisites

- Python 3.7 or later
- An OpenAI API key

### Installation

1. **Clone the repository:**

   ```bash
   git clone https://github.com/your-username/langchain-output-parsers.git
   cd langchain-output-parsers
   ```

2. **Install the required Python packages:**

   ```bash
   pip install langchain_openai python-dotenv
   ```

3. **Set up the `.env` file:**

   Create a `.env` file in the root of your project directory and add your OpenAI API key:

   ```plaintext
   OPENAI_API_KEY=your_openai_api_key_here
   ```

### Running the Script

To run the script and see the different parsers in action:

```bash
python main.py
```

## Explanation of the Parsers

### List Parser

The **CommaSeparatedListOutputParser** is used to parse outputs that are formatted as comma-separated lists. This is particularly useful when you expect the model to generate a list of items.

**Example Usage:**

- Query: "List 3 cat breeds."
- Output: `Siamese, Maine Coon, Bengal`
- Parsed Result: `['Siamese', 'Maine Coon', 'Bengal']`

### Structured Parser

The **StructuredOutputParser** allows you to define a schema for the expected output. The output is then parsed and structured according to this schema, making it easy to extract specific information.

**Example Usage:**

- Query: "Name a country and its capital."
- Output: 
  ```json
  {
    "country": "United States",
    "capital": "Washington, D.C."
  }
  ```
- Parsed Result: `{ 'country': 'United States', 'capital': 'Washington, D.C.' }`

### Class-based (Pydantic) Parser

The **PydanticOutputParser** leverages Pydantic models to enforce data types and structure in the output. This is useful when you require the output to conform to a specific data model.

**Example Usage:**

- Query: "Name any country, its capital, and the country's population."
- Output: 
  ```json
  {
    "name": "India",
    "capital": "New Delhi",
    "population": 1380004385
  }
  ```
- Parsed Result: 
  ```
  name='India' 
  capital='New Delhi' 
  population=1380004385
  ```

## Benefits of Using Parsers

### Structured and Reliable Outputs

Parsers ensure that the outputs generated by the model are structured and adhere to predefined formats. This reduces ambiguity and makes it easier to automate further processing of the results.

### Flexibility in Query Handling

By using different types of parsers, you can handle a wide variety of outputs, from simple lists to complex structured data. This flexibility is particularly useful in applications that require the extraction of specific information from unstructured text.

### Integration with Other Systems

The use of structured data formats makes it easier to integrate the outputs into other systems, such as databases, APIs, or downstream machine learning models.

### Error Reduction

By defining clear schemas or formats, parsers help in reducing errors that may arise from incorrect or unexpected output formats. This increases the robustness of your applications.

## License

This project is licensed under the MIT License.

